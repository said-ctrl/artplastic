{% extends 'base.html.twig' %}
{% block title %}Mon site de com
{% endblock %}

{% block body %}
<style>
    .bull {
        margin: 0;
        overflow: hidden;
    }
    canvas {
        display: block;
    }
</style>

<div class="bull"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    // Initialisation de la scène, de la caméra et du rendu
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.querySelector('.bull').appendChild(renderer.domElement);

    // Chargement de la texture de l'image
    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load('{{ asset('images/' ~ prod3d.image) }}', 
        () => console.log('Texture chargée avec succès'), 
        undefined, 
        (err) => console.error('Erreur de chargement de la texture', err)
    );

    // Création d'un cube avec la texture de l'image
    const geometry = new THREE.BoxGeometry(3, 3, 3);
    const material = new THREE.MeshBasicMaterial({ map: texture });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // Positionnement de la caméra
    camera.position.z = 5;

    // Ajout des contrôles de la souris
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = true;

    // Animation de la rotation du cube
    let rotateCube = true;
    function animate() {
        requestAnimationFrame(animate);
        if (rotateCube) {
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
        }
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // Détection de la souris sur le cube
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(cube);

        if (intersects.length > 0) {
            rotateCube = false;
        } else {
            rotateCube = true;
        }
    }

    window.addEventListener('mousemove', onMouseMove, false);

    // Ajustement de la taille du rendu lors du redimensionnement de la fenêtre
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });
</script>




{% endblock %}

